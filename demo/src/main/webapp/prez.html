<!doctype html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <title>ScalaCompilerDoMatter</title>
   <meta name="description" content="Presentation on Scala Compiler features">
   <meta name="apple-mobile-web-app-capable" content="yes" />
   <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

   <link rel="stylesheet" href="css/reveal.css">
   <link rel="stylesheet" href="css/extension.css">
   <link rel="stylesheet" href="css/theme/sky.css" id="theme">

   <!-- For syntax highlighting -->
   <link rel="stylesheet" href="lib/css/zenburn.css">

   <!-- If the query includes 'print-pdf', use the PDF print sheet -->
   <script>document.write('<link rel="stylesheet" href="css/print/'
      + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper')
      + '.css" type="text/css" media="print">');
   </script>

   <!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
   <![endif]-->
   <style type="text/css" media="screen">
	 #codecontent { 
            background: #E3E4FA;
            display: inline-block;
            width: 100%;
            height: 620px;
            margin:0;
            padding:0;
	    text-align:left;

	    font-family: 'Monaco','Menlo','Ubuntu Mono','Consolas','source-code-pro',monospace;
         }

#codecontent .ace_cursor {
  border-left: 2px solid black;
}
 
      </style>
</head>

<body>
  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h2>Scala Compiler plugins</h2>
        <hr />
        <h3>Why they matter!</h3>
      </section>
      <section>
         <section>
            <h3>Let's start with a simple exemple</h3>
      	    <hr />
	 </section>
         <section>
            <h3>Let's consider that Java Code</h3>
	    <hr />
<pre><code>public class ImmutableClass {
   private String field1;
   private int    field2;

   public ImmutableClass(String f1, int f2) {
      field1 = f1;
      field2 = f2;
   }

   public String getField1() { return field1; }
   public int getField2()    { return field2; }
}</code>
</pre>
Pffeeeew ... much code
	 </section>
         <section>
            <h3>Let's make it simpler</h3>
	    <hr />
<pre><code>@Immutable class ImmutableClass {
   String field1;
   int    field2;
}</code>
</pre>
Ok much better
Thanks to Metaprogramming/AST in Groovy
	 </section>
         <section>
            <h3>Ok ... in Scala there are classes ;)</h3>
	    <hr />
<pre><code>case class ImmutableClass(val String field1, val Int field2)
</code>
</pre>
	 </section>
      </section>
      <section>
        <h1>Agenda</h1>
        <hr />
	<ol>
	  <li>Introduction</li>
          <li>Plumbing</li>
	  <li>Visiting the AST</li>
	  <li>Altering the AST</li>
	  <li>Let's see that in action</li>
          <li>Alternatives</li>
	  <li>Conclusion</li>
        </ol>
      </section>
<section>
<h3>MetaProgramming is not recent</h3>
<hr />
<ul>
<li>Lisp ... in the 60s!</li>
<li>C with macros</li>
<br/>
<li>In JVM world, it has gained some interest:<ul>
<li>apt (limited features)</li>
<li>Emergence of new languages like Groovy or Clojure</li>
<li>or Scala</li>
</ul>
</li>
</ul>
</section>
<section>
<section>
<h3>A use case for this session</h3>
<hr/>
<div>Custom creation of scripts:</div>
<br/>
<ul>
<li>submitted by end users</li>
<li>executed later</li>
</ul>
</section>
<section>
<div>
<h3>Some constraints:</h3>
<hr/>
<ul>
<li>local development</li>
<li>API interaction constraints</li>
<li>Security/Sandboxing</li>
<li>DSL capabilities</li>
</ul>
</div>
</section>
</section>
<section>
<section>
<h3>How to create Compiler plugins</h3>
<hr/>
<p><small><a href="http://www.scala-lang.org/old/node/140">http://www.scala-lang.org/old/node/140</a></small></p>
</section>
<section>
<h3>When to write a plugin</h3>
<hr/>
<div style="text-align:left">Modify the compiler's behavior</div>
<div style="text-align:left">Should not be so frequent</div>
<br/>
<ul>
<li>add additional compile-time checks</li>
<li>add compile-time optimizations</li>
<li>rewrite Scala syntax into an entirely different, custom meaning
<ul><li>Dangerous =&gt; Looks like a good reason to give a try ;)</li></ul
</li>
</ul>
</section>
<section>
<ol>
<li>Create a java archive containing a scalac-plugin.xml</li>
<li>Define inside which class is your plugin entry point</li>
<li>Your code can be in the same jar (for small plugins) or as separated projects that you add in your project dependencies</li>
</ol>
<br/>
<pre><code>&lt;plugin&gt;
  &lt;name&gt;myPluginName&lt;/name&gt;
  &lt;classname&gt;my.package.path.MyPlugin&lt;/classname&gt;
&lt;/plugin&gt;</code></pre>
</section>
<section>
First create your plugin class:
<br/>
<pre><code>class MyPlugin(val global: Global) extends Plugin {
  val name = "myplugin"
  val description = "Provide a description"
  val components = List[PluginComponent](MyComponent)
</code></pre>
</section>
<section>
Define the previously referenced Components:
<br/>
<pre><code>private object MyComponent extends PluginComponent {
  val runsAfter = List[String]("refchecks");
  //override val runsBefore = List[String]("tailcalls");

  val phaseName = MyPlugin.this.name
  def newPhase(_prev: Phase) = new MyPhase(_prev)    
</code></pre>
</section>
<section>
Finally define your phase

<pre><code>class MyPhase(prev: Phase) extends StdPhase(prev) {
  override def name = MyPlugin.this.name

  def apply(unit: CompilationUnit) {
    // Here starts the AST analysis
</code></pre>
</section>
<section>
<h3>How to use your plugin</h3>
<hr/>
<ul>
<li>scala-compiler.jar in the class path</li>
<li>pass the -Xplugin: or -Xpluginsdir argument</li>
</ul>
<br/>
<div>You also can use sbt http://www.scala-sbt.org/0.13.0/docs/Detailed-Topics/Compiler-Plugins.html</div>
<pre><code>autoCompilerPlugins := true

//addCompilerPlugin("org.scala-lang.plugins" % "continuations" % "2.10.3")

libraryDependencies +=
    compilerPlugin("org.scala-lang.plugins" % "continuations" % scalaVersion.value)

scalacOptions += "-P:continuations:enable"
</code></pre>
</section>
<section>
<h3>Useful Compiler Options</h3>
<hr/>
<div style="text-align:left">use scalac -X</div>
<br/>
<div style="text-align:left">For example</div>
<ul>
<li>-Xshow-phases</li>
<li>-Xplugin-list</li>
</ul>
</section>
<section>
<h3>Customize plugin with options</h3>
<hr/>
<div style="text-align:left">Adding your own command line options</div>
<br/>
<div style="text-align:left">-P: followed by the name of the plugin. For example, -P:continuations:enable</div>
<pre><code>override def processOptions(
  options: List[String],
  error: String =&gt; Unit)

override val optionsHelp: Option[String]
</code></pre>
</section>
</section>
<section>
<section>
<h3>How does the AST look like in Scala</h3>
<hr/>
<div>http://docs.scala-lang.org/overviews/reflection/overview.html</div>
<pre><code>import scala.reflect.runtime.universe._

def tree = reify { // some code }.tree

show(tree)
showRaw(tree)
</code></pre>
</section>
<section>
Subclasses of TermTree which represent terms
Subclasses of TypTree which represent types
Subclasses of SymTree which introduce or reference definitions.

Class ValDef
Expr
Apply
ClassDef
Block
Constant
</section>
</section>
<section>
<section>
<h3>Visiting the AST</h3>
<hr/>
Manual
Pattern Matching
</section>
<section>
<h3>Visiting with Traverser</h3>
<hr/>
<div>Traverser makes sure to visit every node in a given tree, in a breadth-first search.</div>

To use a Traverser, simply subclass Traverser and override method traverse. In doing so, you can simply provide custom logic to handle only the cases
 you're interested in. 
 
object traverser extends Traverser {
override def traverse(tree: Tree): Unit = tree match {
 case app @ Apply(fun, args) =&gt;
    //Some logic  
    //super.traverse(fun)
    //super.traverseTrees(args)
  case _ =&gt; super.traverse(tree)
  }
}

</section>
<section>
// Todo 2 use cases
// API recording
// System.exit call
We are in Scala so we must rely on type

for (global.Apply(fun, _) &lt;- unit.body) {
            fun.symbol match {
              case method: global.MethodSymbol =&gt;
                val classSymbol = method.owner
                val systemSymbol = global.findMemberFromRoot(global.TermName(classOf[System].getName))
                if ((method.nameString == "exit")
                  &amp;&amp; (classSymbol.tpe &lt;:&lt; systemSymbol.tpe))
                  unit.error(fun.pos, "System.exit forbidden")
              case _ =&gt; ()

</section>    
</section>
<section>
<section>
<h3>Modifying the AST</h3>
<hr/>
Manual
</section>
<section>
Quasiquotes

Liftable

Liftable type class, which defines how values are transformed into trees when spliced in. 
We provide instances of Liftable for primitives and strings, which wrap those in Literal(Constant(...)). You might want to define your own instances for simple case classes and lists.

    trait Liftable[T] {
    def apply(universe: api.Universe, value: T): universe.Tree
    }


</section>
<section>
Reify

Tree Creation via reify

Method reify simply takes a Scala expression as an argument, and produces that argument’s typed Tree representation as a result.

Tree creation via method reify is the recommended way of creating trees in Scala Reflection. To see why, let’s start with a small example:

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> { val tree = reify(println(2)).tree; showRaw(tree) }
    res0: String = Apply(Select(Select(This(newTypeName("scala")), newTermName("Predef")), newTermName("println")), List(Literal(Constant(2))))

Here, we simply reify the call to println(2)– that is, we convert the expression println(2) to its corresponding tree representation. Then we output the raw tree. Note that the println method was transformed to scala.Predef.println. Such transformations ensure that regardless of where the result of reify is used, it will not unexpectedly change its meaning. For example, even if this println(2) snippet is later inserted into a block of code that defines its own println, it wouldn’t affect the behavior of the snippet.

This way of creating trees is thus hygenic, in the sense that it preserves bindings of identifiers.
Splicing Trees

Using reify also allows one to compose trees from smaller trees. This is done using Expr.splice.

Note: Expr is reify’s return type. It can be thought of as a simple wrapper which contains a typed Tree, a TypeTag and a handful of reification-relevant methods, such as splice. For more information about Exprs, see the relevant section of this guide.

For example, let’s try to construct a tree representing println(2) using splice:

    scala> val x = reify(2)
    x: reflect.runtime.universe.Expr[Int(2)] = Expr[Int(2)](2)
    scala> reify(println(x.splice))
    res1: reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println(2))

Here, we reify 2 and println separately, and simply splice one into the other.

Note, however, that there is a requirement for the argument of reify to be valid and typeable Scala code. If instead of the argument to println we wanted to abstract over the println itself, it wouldn’t be possible:

    scala> val fn = reify(println)
    fn: reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println())
    scala> reify(fn.splice(2))
    <console>:12: error: Unit does not take parameters
    reify(fn.splice(2))
    ^

As we can see, the compiler assumes that we wanted to reify a call to println with no arguments, when what we really wanted was to capture the name of the function to be called.

These types of use-cases are currently inexpressible when using reify.
</section>
<section>
Tree Creation via parse on ToolBoxes

Toolboxes can be used to typecheck, compile, and execute abstract syntax trees. A toolbox can also be used to parse a string into an AST.

Note: Using toolboxes requires scala-compiler.jar to be on the classpath.

Let’s see how parse deals with the println example from the previous section:

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> import scala.tools.reflect.ToolBox
    import scala.tools.reflect.ToolBox
    scala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
    tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@7bc979dd
    scala> showRaw(tb.parse("println(2)"))
    res2: String = Apply(Ident(newTermName("println")), List(Literal(Constant(2))))

It’s important to note that, unlike reify, toolboxes aren’t limited by the typeability requirement– although this flexibility is achieved by sacrificing robustness. That is, here we can see that parse, unlike reify, doesn’t reflect the fact that println should be bound to the standard println method.

Note: when using macros, one shouldn’t use ToolBox.parse. This is because there’s already a parse method built into the macro context. For example:

    scala> import language.experimental.macros
    import language.experimental.macros
    scala> def impl(c: scala.reflect.macros.Context) = c.Expr[Unit](c.parse("println(2)"))
    impl: (c: scala.reflect.macros.Context)c.Expr[Unit]
    scala> def test = macro impl
    test: Unit
    scala> test
    2

Typechecking with ToolBoxes

As earlier alluded to, ToolBoxes enable one to do more than just constructing trees from strings. They can also be used to typecheck, compile, and execute trees.

In addition to outlining the structure of the program, trees also hold important information about the semantics of the program encoded in symbol (a symbol assigned to trees that introduce or reference definitions), and tpe (the type of the tree). By default these fields are empty, but typechecking fills them in.

When using the runtime reflection framework, typechecking is implemented by ToolBox.typeCheck. When using macros, at compile time one can use the Context.typeCheck method.

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> val tree = reify { "test".length }.tree
    tree: reflect.runtime.universe.Tree = "test".length()
    scala> import scala.tools.reflect.ToolBox
    import scala.tools.reflect.ToolBox
    scala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
    tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = ...
    scala> val ttree = tb.typeCheck(tree)
    ttree: tb.u.Tree = "test".length()
    scala> ttree.tpe
    res5: tb.u.Type = Int
    scala> ttree.symbol
    res6: tb.u.Symbol = method length

Here, we simply create a tree that represents a call to "test".length, and use ToolBox tb’s typeCheck method to typecheck the tree. As we can see, ttree gets the correct type, Int, and its Symbol is correctly set.
Tree Creation via Manual Construction

If all else fails, one can manually construct trees. This is the most low-level way to create trees, and it should only be attempted if no other approach works. It sometimes offers greater flexibility when compared with parse, though this flexibility is achieved at a cost of excessive verbosity and fragility.

Our earlier example involving println(2) can be manually constructed as follows:

    scala> Apply(Ident(newTermName("println")), List(Literal(Constant(2))))
    res0: reflect.runtime.universe.Apply = println(2)

The canonical use case for this technique is when the target tree needs to be assembled from dynamically created parts, which don’t make sense in isolation from one another. In that case, reify will most likely be inapplicable, because it requires its argument to be typeable. parse might not work either, since quite often, trees are assembled on sub-expression level, with individual parts being inexpressible as Scala sources.
</section>
<section>
Other options
Transformer
TypingTransformer
NodeTree
</section>
</section>
      <section>
      <section>
        <h3>Let's see that in action</h3>
	</section>
      <section>
	<h3>Short Explanation</h3>
<hr/>
<ul>
<li>Presentation embedded inside a server</li>
<li>The next eval page just sends code to the server - Ajax</li>
<li>A scala Eval instance is spawned
<ul><li>Loads jars from a dedicated lib directory</li>
<li>Uses plugins from another dir</li>
<li>Evaluates the passed script</li>runs the script
<li>Hot reload</li>
</ul>
      </section>
	<!--section>
        <iframe style="display: inline-block; width: 100%; height: 720px; vertical-align: top;" src="index.html"></iframe> 
        </section-->
        <section>
         <div style="display: inline-block; width: 54%; height: 100%; vertical-align: top;">
     <div style="text-align:left; font-size:0.8em">input:</div>
      <div id="codecontent" style="font-size:0.7em; line-height:100%" ></div></div>
      <div style="display: inline-block; width: 44%; height: 100%; vertical-align: top; margin-left:10px">
	      <div style="text-align:left ; font-size:0.8em">output:</div>
	      <pre id="output" style="font-size:0.7em; background-color: #eee; height: 282px; width: 100%; -moz-box-sizing: border-box; margin-bottom:1.5%; margin-top:0; overflow:scroll; line-height: 90%"></pre>
	      <div style="text-align:left; margin-top:2%; font-size:0.8em">status:</div>
	 <pre id="status" style="font-size:0.7em; background-color: #eee; height: 282px; width: 100%; -moz-box-sizing: border-box; margin-top:0; overflow:scroll; line-height: 90%"></pre>
      </div>
      <div style="text-align:left"><input style="font-size:0.6em" type="submit" onClick="submitContent()" value="eval" /></div>
        </section>
	</section>
	<section>
AST is too complex and error prone
Are there alternatives to solve the different use cases
Macros
JAAS - sandboxing - not sure it is really easy and here we can have a granularity in sandboxing
Traits AOP
Futures
</section>
<section>
<section>
<h3>Conclusion</h3>
<hr/>
<div>Do Scala Compiler really matter?</div>
<div>Should we use them?</div>
</section>
<section>
<h3>Yes but ...</h3>
<hr/>
<ul>
<li>Use them carefully, when needed</li>
<br/>
<li>They are used in various scala parts:
<ul><li>macros and their using projects (like scala-async)</li>
<li>continuations</li>
</ul></li>
<br/>
<li>By default, consider alternatives</li>
<li>They can be very useful</li>
<br/>
<li>But be ready to dive into doc ...</li>
<li>Might impact compile time</li>
</ul>
</section>	
</section>
      <section>
      <h3>Further reading</h3>
      <ul>
	      <li><small><a href="http://www.scala-lang.org/old/node/140">http://www.scala-lang.org/old/node/140</a> - marked as deprecated</small></li>
      <li><small><a href="http://docs.scala-lang.org/overviews/reflection/overview.html">http://docs.scala-lang.org/overviews/reflection/overview.html</a></small></li>
      <li><small><a href="http://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/docs/examples/plugintemplate">http://lampsvn.epfl.ch/trac/scala/browser/scala/trunk/docs/examples/plugintemplate</a></small></li>
      <li><small><a href="http://www.scala-lang.org/files/archive/nightly/docs-master/compiler/#scala.tools.nsc.Global">http://www.scala-lang.org/files/archive/nightly/docs-master/compiler/#scala.tools.nsc.Global</a></small></li>
      <br/>
      <li><small><a href="http://docs.scala-lang.org/overviews/macros/toc.html">http://docs.scala-lang.org/overviews/macros/toc.html</a></small></li>
      <li><small><a href="http://scalamacros.org/">http://scalamacros.org/</a></small></li>
      </ul>
      </section>
      <section>
        <h3>Questions ?</h3>
      </section>
    <section>
    <h3>Thanks for your attention</h3>
    <hr/>
    <div style="text-align:left">
       <p><small>Based on Reveal.js created by <a href="http://hakim.se">Hakim El Hattab</a> / <a href="http://twitter.com/hakimel">@hakimel</a></small></p>
       <p><small>Powered by vim: <a href="http://www.vim.org/">http://www.vim.org/</a></small></p>
       <p><small>Special thanks @:<ul>
       <li>Eugene Burmako for his help and advice</li>
       <li>Mathieu Bruyen for his support</li></ul></small></p>
</div>
    </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  
  <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls : true,
      progress : true,
      history : true,
      center : true,

      theme : Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition : Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

      //config.width
      width: 1200,
      height: 800,

      // Optional libraries used to extend on reveal.js
      dependencies : [ {
        src : 'lib/js/classList.js',
        condition : function() {
          return !document.body.classList;
        }
      }, {
        src : 'plugin/markdown/marked.js',
        condition : function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src : 'plugin/markdown/markdown.js',
        condition : function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src : 'plugin/highlight/highlight.js',
        async : true,
        callback : function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src : 'plugin/zoom-js/zoom.js',
        async : true,
        condition : function() {
          return !!document.body.classList;
        }
      }, {
        src : 'plugin/notes/notes.js',
        async : true,
        condition : function() {
          return !!document.body.classList;
        }
      } ]
    });
   </script>
   
     <script src="js/ace.js" type="text/javascript" charset="utf-8"></script>
      <script>
   var editor = ace.edit("codecontent");
   editor.setTheme("ace/theme/tomorrow");
   editor.getSession().setMode("ace/mode/scala");

   function submitContent() {
      var content='{content: '+JSON.stringify(editor.getValue())+'}'
      var xmlHttpReq = false;
      // Mozilla/Safari
      if (window.XMLHttpRequest) {
        xmlHttpReq = new XMLHttpRequest();
      }
      // IE
      else if (window.ActiveXObject) {
        xmlHttpReq = new ActiveXObject("Microsoft.XMLHTTP");
      }
  
      xmlHttpReq.onreadystatechange = function() {
      if (xmlHttpReq.readyState == 4) {
        var result = JSON.parse(xmlHttpReq.responseText);
        document.getElementById('output').innerHTML = result.output;
        document.getElementById('status').innerHTML = result.compilationStatus;
      }
    }     
    xmlHttpReq.open('POST', 'eval', true);
    xmlHttpReq.setRequestHeader('Content-Type', 'application/json');
    xmlHttpReq.send(content);
}
      </script>
</body>
</html>
