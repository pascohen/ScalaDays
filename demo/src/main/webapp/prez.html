<!doctype html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <title>ScalaCompilerDoMatter</title>
   <meta name="description" content="Presentation on Scala Compiler features">
   <meta name="apple-mobile-web-app-capable" content="yes" />
   <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

   <link rel="stylesheet" href="css/reveal.css">
   <link rel="stylesheet" href="css/extension.css">
   <link rel="stylesheet" href="css/theme/sky.css" id="theme">

   <!-- For syntax highlighting -->
   <link rel="stylesheet" href="lib/css/zenburn.css">

   <!-- If the query includes 'print-pdf', use the PDF print sheet -->
   <script>document.write('<link rel="stylesheet" href="css/print/'
      + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper')
      + '.css" type="text/css" media="print">');
   </script>

   <!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
   <![endif]-->
   <style type="text/css" media="screen">
	 #codecontent { 
            background: #E3E4FA;
            display: inline-block;
            width: 100%;
            height: 620px;
            margin:0;
            padding:0;
	    text-align:left;

	    font-family: 'Monaco','Menlo','Ubuntu Mono','Consolas','source-code-pro',monospace;
         }

#codecontent .ace_cursor {
  border-left: 2px solid black;
}
 
      </style>
</head>

<body>
  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h2>Scala Compiler plugins</h2>
        <hr />
        <h3>Why they matter!</h3>
      </section>
      <section>
         <section>
            <h3>Let's start with a simple exemple</h3>
      	    <hr />
	 </section>
         <section>
            <h3>Let's consider that Java Code</h3>
	    <hr />
<pre><code>public class ImmutableClass {
   private String field1;
   private int    field2;

   public ImmutableClass(String f1, int f2) {
      field1 = f1;
      field2 = f2;
   }

   public String getField1() { return field1; }
   public int getField2()    { return field2; }
}</code>
</pre>
Pffeeeew ... much code
	 </section>
         <section>
            <h3>Let's make it simpler</h3>
	    <hr />
<pre><code>@Immutable class ImmutableClass {
   String field1;
   int    field2;
}</code>
</pre>
Ok much better
Thanks to Metaprogramming/AST in Groovy
	 </section>
         <section>
            <h3>Ok ... in Scala there are classes ;)</h3>
	    <hr />
<pre><code>case class ImmutableClass(val String field1, val Int field2)
</code>
</pre>
	 </section>
      </section>
      <section>
        <h1>Agenda</h1>
        <hr />
	<ol>
	  <li>Introduction</li>
          <li>Plumbing</li>
	  <li>Visiting the AST</li>
	  <li>Altering the AST</li>
	  <li>Let's see that in action</li>
          <li>Alternatives</li>
	  <li>Conclusion</li>
        </ol>
      </section>
<section>
MetaProgramming is not recent
In Lisp in the 60s
In C with macros
In the JVM world it has gained some interest since apt limited features and emergence of new languages like Groovy or Clojure
</section>
<section>
A use case for this session
Custom creation of scripts submitted by end users that are going to be executed later
Some constraints:
local development 
API constraints
Security/Sandboxing
DSL capabilities
</section>
<section>
How to create Compiler plugins
some infra
sbt
plugin.xml
</section>
<section>
How does the AST look like in Scala
show raw

http://docs.scala-lang.org/overviews/reflection/overview.html

import scala.reflect.runtime.universe._

def tree = reify { final class C { def x = 2 } }.tree
show(tree)
howRaw(tree)

Class ValDef
Expr
Apply
ClassDef


    Subclasses of TermTree which represent terms, e.g., method invocations are represented by Apply nodes, object instantiation is achieved using New nodes, etc.
    Subclasses of TypTree which represent types that are explicitly specified in program source code, e.g., List[Int] is parsed as AppliedTypeTree. Note: TypTree is not misspelled, nor is it conceptually the same as TypeTree– TypeTree is something different. That is, in situations where Types are constructed by the compiler (_e.g.,_ during type inference), they can be wrapped in TypeTree trees and integrated into the AST of the program.
    Subclasses of SymTree which introduce or reference definitions. Examples of the introduction of new definitions include ClassDefs which represent class and trait definitions, or ValDef which represent field and parameter definitions. Examples of the reference of existing definitions include Idents which refer to an existing definition in the current scope such as a local variable or a method.

    
</section>
<section>
Manual
Pattern Matching

Visiting with Traverser

Traversal via Traverser

In situations where it’s necessary to traverse an entire tree from top to bottom, using traversal via pattern matching would be infeasible– to do it this way, one must individually handle every type of node that we might come across in the pattern match. Thus, in these situations, typically class Traverser is used.

Traverser makes sure to visit every node in a given tree, in a breadth-first search.

To use a Traverser, simply subclass Traverser and override method traverse. In doing so, you can simply provide custom logic to handle only the cases you’re interested in. For example, if, given our x.$plus(2).$plus(3) tree from the previous section, we would like to collect all Apply nodes, we could do:

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> val tree = Apply(Select(Apply(Select(Ident(newTermName("x")), newTermName("$plus")), List(Literal(Constant(2)))), newTermName("$plus")), List(Literal(Constant(3))))
    tree: reflect.runtime.universe.Apply = x.$plus(2).$plus(3)
    scala> object traverser extends Traverser {
    | var applies = List[Apply]()
    | override def traverse(tree: Tree): Unit = tree match {
    | case app @ Apply(fun, args) =>
    | applies = app :: applies
    | super.traverse(fun)
    | super.traverseTrees(args)
    | case _ => super.traverse(tree)
    | }
    | }
    defined module traverser

In the above, we intend to construct a list of Apply nodes that we find in our given tree.

We achieve this by in effect adding a special case to the already breadth-first traverse method defined in superclass Traverser, via subclass traverser’s overridden traverse method. Our special case affects only nodes that match the pattern Apply(fun, args), where fun is some function (represented by a Tree) and args is a list of arguments (represented by a list of Trees).

When a the tree matches the pattern (_i.e.,_ when we have an Apply node), we simply add it to our List[Apply], applies, and continue our traversal.

Note that, in our match, we call super.traverse on the function fun wrapped in our Apply, and we call super.traverseTrees on our argument list args (essentially the same as super.traverse, but for List[Tree] rather than a single Tree). In both of these calls, our objective is simple– we want to make sure that we use the default traverse method in Traverser because we don’t know whether the Tree that represents fun contains our Apply pattern– that is, we want to traverse the entire sub-tree. Since the Traverser superclass calls this.traverse, passing in every nested sub- tree, eventually our custom traverse method is guaranteed to be called for each sub-tree that matches our Apply pattern.

To trigger the traverse and to see the resulting List of matching Apply nodes, simply do:

    scala> traverser.traverse(tree)
    scala> traverser.applies
    res0: List[reflect.runtime.universe.Apply] = List(x.$plus(2), x.$plus(2).$plus(3))
    
</section>
<section>
Manual
Quasiquotes



Quasiquotes are shipped with recent milestone builds of Scala 2.11, starting from 2.11.0-M4. They are also available in Scala 2.10 with the macro paradise plugin. Follow the instructions at the “Macro Paradise” page to download and use our compiler plugin.

Note that both in 2.10.x and in 2.11, quasiquotes don’t bring transitive dependencies on macro paradise, which means that you can write macros using quasiquotes from macro paradise for 2.10.x, and people will be able to use them with vanilla 2.10.x. Neither your code that uses quasiquotes from macro paradise, nor the users of such code will need to have macro paradise on their classpath at runtime.
Intuition

Consider an async macro annotation, which takes a class or an object and duplicates their methods with asynchronous counterparts wrapped in future.

    @async
    class D {
    def x = 2
    // def asyncX = future { 2 }
    }
    val d = new D
    d.asyncX onComplete {
    case Success(x) => println(x)
    case Failure(_) => println("failed")
    }

An implementation of such a macro might look as the code at the snippet below. This routine - acquire, destructure, wrap in generated code, restructure again - is quite familiar to macro writers.

    case ClassDef(_, _, _, Template(_, _, defs)) =>
    val defs1 = defs collect {
    case DefDef(mods, name, tparams, vparamss, tpt, body) =>
    val tpt1 = if (tpt.isEmpty) tpt else AppliedTypeTree(
    Ident(newTermName("Future")), List(tpt))
    val body1 = Apply(
    Ident(newTermName("future")), List(body))
    val name1 = newTermName("async" + name.capitalize)
    DefDef(mods, name1, tparams, vparamss, tpt1, body1)
    }
    Template(Nil, emptyValDef, defs ::: defs1)

However even seasoned macro writers will admit that this code, even though it’s quite simple, is exceedingly verbose, requiring one to understand the details internal representation of code snippets, e.g. the difference between AppliedTypeTree and Apply. Quasiquotes provide a neat domain-specific language that represents parameterized Scala snippets with Scala:

    val q"class $name extends Liftable { ..$body }" = tree
    val newdefs = body collect {
    case q"def $name[..$tparams](...$vparamss): $tpt = $body" =>
    val tpt1 = if (tpt.isEmpty) tpt else tq"Future[$tpt]"
    val name1 = newTermName("async" + name.capitalize)
    q"def $name1[..$tparams](...$vparamss): $tpt1 = future { $body }"
    }
    q"class $name extends AnyRef { ..${body ++ newdefs} }"

At the moment quasiquotes suffer from SI-6842, which doesn’t let one write the code as concisely as mentioned above. A series of casts has to be applied to get things working.
Details

Quasiquotes are implemented as a part of the scala.reflect.api.Universe cake, which means that it is enough to do import c.universe._ to use quasiquotes in macros. Exposed API provides q, tq, cq and pq string interpolators (corresponding to term and type quasiquotes), which support both construction and deconstruction, i.e. can be used both in normal code and on the left-hand side of a pattern case.
Flavor	Works with	Construction	Deconstruction
q	Term trees	q"future{ $body }"	case q"future{ $body }" =>
tq	Type trees	tq"Future[$t]"	case tq"Future[$t]" =>
cq	Cases	cq"x => x"	case cq"$pat => ${_}" =>
pq	Patterns	pq"xs @ (hd :: tl)"	case pq"$id @ ${_}" =>

Unlike regular string interpolators, quasiquotes support multiple flavors of splices in order to distinguish between inserting/extracting single trees, lists of trees and lists of lists of trees. Mismatching cardinalities of splicees and splice operators results in a compile-time error.

    scala> val name = TypeName("C")
    name: reflect.runtime.universe.TypeName = C
    scala> val q"class $name1" = q"class $name"
    name1: reflect.runtime.universe.Name = C
    scala> val args = List(Literal(Constant(2)))
    args: List[reflect.runtime.universe.Literal] = List(2)
    scala> val q"foo(..$args1)" = q"foo(..$args)"
    args1: List[reflect.runtime.universe.Tree] = List(2)
    scala> val argss = List(List(Literal(Constant(2))), List(Literal(Constant(3))))
    argss: List[List[reflect.runtime.universe.Literal]] = List(List(2), List(3))
    scala> val q"foo(...$argss1)" = q"foo(...$argss)"
    argss1: List[List[reflect.runtime.universe.Tree]] = List(List(2), List(3))

Tips and tricks
Liftable

To simplify splicing of non-trees, quasiquotes provide the Liftable type class, which defines how values are transformed into trees when spliced in. We provide instances of Liftable for primitives and strings, which wrap those in Literal(Constant(...)). You might want to define your own instances for simple case classes and lists.

    trait Liftable[T] {
    def apply(universe: api.Universe, value: T): universe.Tree
    }



Reify



Tree Creation via reify

Method reify simply takes a Scala expression as an argument, and produces that argument’s typed Tree representation as a result.

Tree creation via method reify is the recommended way of creating trees in Scala Reflection. To see why, let’s start with a small example:

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> { val tree = reify(println(2)).tree; showRaw(tree) }
    res0: String = Apply(Select(Select(This(newTypeName("scala")), newTermName("Predef")), newTermName("println")), List(Literal(Constant(2))))

Here, we simply reify the call to println(2)– that is, we convert the expression println(2) to its corresponding tree representation. Then we output the raw tree. Note that the println method was transformed to scala.Predef.println. Such transformations ensure that regardless of where the result of reify is used, it will not unexpectedly change its meaning. For example, even if this println(2) snippet is later inserted into a block of code that defines its own println, it wouldn’t affect the behavior of the snippet.

This way of creating trees is thus hygenic, in the sense that it preserves bindings of identifiers.
Splicing Trees

Using reify also allows one to compose trees from smaller trees. This is done using Expr.splice.

Note: Expr is reify’s return type. It can be thought of as a simple wrapper which contains a typed Tree, a TypeTag and a handful of reification-relevant methods, such as splice. For more information about Exprs, see the relevant section of this guide.

For example, let’s try to construct a tree representing println(2) using splice:

    scala> val x = reify(2)
    x: reflect.runtime.universe.Expr[Int(2)] = Expr[Int(2)](2)
    scala> reify(println(x.splice))
    res1: reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println(2))

Here, we reify 2 and println separately, and simply splice one into the other.

Note, however, that there is a requirement for the argument of reify to be valid and typeable Scala code. If instead of the argument to println we wanted to abstract over the println itself, it wouldn’t be possible:

    scala> val fn = reify(println)
    fn: reflect.runtime.universe.Expr[Unit] = Expr[Unit](scala.this.Predef.println())
    scala> reify(fn.splice(2))
    <console>:12: error: Unit does not take parameters
    reify(fn.splice(2))
    ^

As we can see, the compiler assumes that we wanted to reify a call to println with no arguments, when what we really wanted was to capture the name of the function to be called.

These types of use-cases are currently inexpressible when using reify.
Tree Creation via parse on ToolBoxes

Toolboxes can be used to typecheck, compile, and execute abstract syntax trees. A toolbox can also be used to parse a string into an AST.

Note: Using toolboxes requires scala-compiler.jar to be on the classpath.

Let’s see how parse deals with the println example from the previous section:

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> import scala.tools.reflect.ToolBox
    import scala.tools.reflect.ToolBox
    scala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
    tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@7bc979dd
    scala> showRaw(tb.parse("println(2)"))
    res2: String = Apply(Ident(newTermName("println")), List(Literal(Constant(2))))

It’s important to note that, unlike reify, toolboxes aren’t limited by the typeability requirement– although this flexibility is achieved by sacrificing robustness. That is, here we can see that parse, unlike reify, doesn’t reflect the fact that println should be bound to the standard println method.

Note: when using macros, one shouldn’t use ToolBox.parse. This is because there’s already a parse method built into the macro context. For example:

    scala> import language.experimental.macros
    import language.experimental.macros
    scala> def impl(c: scala.reflect.macros.Context) = c.Expr[Unit](c.parse("println(2)"))
    impl: (c: scala.reflect.macros.Context)c.Expr[Unit]
    scala> def test = macro impl
    test: Unit
    scala> test
    2

Typechecking with ToolBoxes

As earlier alluded to, ToolBoxes enable one to do more than just constructing trees from strings. They can also be used to typecheck, compile, and execute trees.

In addition to outlining the structure of the program, trees also hold important information about the semantics of the program encoded in symbol (a symbol assigned to trees that introduce or reference definitions), and tpe (the type of the tree). By default these fields are empty, but typechecking fills them in.

When using the runtime reflection framework, typechecking is implemented by ToolBox.typeCheck. When using macros, at compile time one can use the Context.typeCheck method.

    scala> import scala.reflect.runtime.universe._
    import scala.reflect.runtime.universe._
    scala> val tree = reify { "test".length }.tree
    tree: reflect.runtime.universe.Tree = "test".length()
    scala> import scala.tools.reflect.ToolBox
    import scala.tools.reflect.ToolBox
    scala> val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
    tb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = ...
    scala> val ttree = tb.typeCheck(tree)
    ttree: tb.u.Tree = "test".length()
    scala> ttree.tpe
    res5: tb.u.Type = Int
    scala> ttree.symbol
    res6: tb.u.Symbol = method length

Here, we simply create a tree that represents a call to "test".length, and use ToolBox tb’s typeCheck method to typecheck the tree. As we can see, ttree gets the correct type, Int, and its Symbol is correctly set.
Tree Creation via Manual Construction

If all else fails, one can manually construct trees. This is the most low-level way to create trees, and it should only be attempted if no other approach works. It sometimes offers greater flexibility when compared with parse, though this flexibility is achieved at a cost of excessive verbosity and fragility.

Our earlier example involving println(2) can be manually constructed as follows:

    scala> Apply(Ident(newTermName("println")), List(Literal(Constant(2))))
    res0: reflect.runtime.universe.Apply = println(2)

The canonical use case for this technique is when the target tree needs to be assembled from dynamically created parts, which don’t make sense in isolation from one another. In that case, reify will most likely be inapplicable, because it requires its argument to be typeable. parse might not work either, since quite often, trees are assembled on sub-expression level, with individual parts being inexpressible as Scala sources.
</section>
      <section>
      <section>
        <h3>Let's see that in action</h3>
	</section>
      <section>
Explanations
Presentation inside a server
The eval page just sends code to the server
server creates a scala Eval instance that loads jars in a dedicated lib and plugins into another
and runs the script
Advantage is that we can change the plugins/jar on the fly without restarting the application
      </section>
	<!--section>
        <iframe style="display: inline-block; width: 100%; height: 720px; vertical-align: top;" src="index.html"></iframe> 
        </section-->
        <section>
         <div style="display: inline-block; width: 54%; height: 100%; vertical-align: top;">
     <div style="text-align:left; font-size:0.8em">input:</div>
      <div id="codecontent" style="font-size:0.7em; line-height:100%" ></div></div>
      <div style="display: inline-block; width: 44%; height: 100%; vertical-align: top; margin-left:10px">
	      <div style="text-align:left ; font-size:0.8em">output:</div>
	      <pre id="output" style="font-size:0.7em; background-color: #eee; height: 282px; width: 100%; -moz-box-sizing: border-box; margin-bottom:1.5%; margin-top:0; overflow:scroll; line-height: 90%"></pre>
	      <div style="text-align:left; margin-top:2%; font-size:0.8em">status:</div>
	 <pre id="status" style="font-size:0.7em; background-color: #eee; height: 282px; width: 100%; -moz-box-sizing: border-box; margin-top:0; overflow:scroll; line-height: 90%"></pre>
      </div>
      <div style="text-align:left"><input style="font-size:0.6em" type="submit" onClick="submitContent()" value="eval" /></div>
        </section>
	</section>
	<section>
AST is too complex and error prone
Are there alternatives to solve the different use cases
Macros
JAAS - sandboxing - not sure it is really easy and here we can have a granularity in sandboxing
Traits AOP
Futures
</section>
	<section>
	Conclusion:Do Scala Compiler really matter?Should I use them
	They are used in various scala parts
	macros of course: https://github.com/scalamacros/sbt-example
	continuations
	scala-async
	By default avoid and consider alternatives
	but they can be very useful. It is definitely not easy
	compile time impact
	
			</section>
      <section>
        <h3>Further reading</h3>
        http://radar.oreilly.com/2011/09/java7-features.html
        http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html
        https://www.youtube.com/watch?v=C_QbkGU_lqY
      </section>
      <section>
        <h3>Questions ?</h3>
      </section>
    <section>
       <h3>Thanks for your attention</h3>
       <p><small>Based on Reveal.js created by <a href="http://hakim.se">Hakim El Hattab</a> / <a href="http://twitter.com/hakimel">@hakimel</a></small></p>
       <p><small>Powered by vim: <a href="http://www.vim.org/">http://www.vim.org/</a></small></p>
    </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>
  
  <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls : true,
      progress : true,
      history : true,
      center : true,

      theme : Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition : Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

      //config.width
      width: 1200,
      height: 800,

      // Optional libraries used to extend on reveal.js
      dependencies : [ {
        src : 'lib/js/classList.js',
        condition : function() {
          return !document.body.classList;
        }
      }, {
        src : 'plugin/markdown/marked.js',
        condition : function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src : 'plugin/markdown/markdown.js',
        condition : function() {
          return !!document.querySelector('[data-markdown]');
        }
      }, {
        src : 'plugin/highlight/highlight.js',
        async : true,
        callback : function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src : 'plugin/zoom-js/zoom.js',
        async : true,
        condition : function() {
          return !!document.body.classList;
        }
      }, {
        src : 'plugin/notes/notes.js',
        async : true,
        condition : function() {
          return !!document.body.classList;
        }
      } ]
    });
   </script>
   
     <script src="js/ace.js" type="text/javascript" charset="utf-8"></script>
      <script>
   var editor = ace.edit("codecontent");
   editor.setTheme("ace/theme/tomorrow");
   editor.getSession().setMode("ace/mode/scala");

   function submitContent() {
      var content='{content: '+JSON.stringify(editor.getValue())+'}'
      var xmlHttpReq = false;
      // Mozilla/Safari
      if (window.XMLHttpRequest) {
        xmlHttpReq = new XMLHttpRequest();
      }
      // IE
      else if (window.ActiveXObject) {
        xmlHttpReq = new ActiveXObject("Microsoft.XMLHTTP");
      }
  
      xmlHttpReq.onreadystatechange = function() {
      if (xmlHttpReq.readyState == 4) {
        var result = JSON.parse(xmlHttpReq.responseText);
        document.getElementById('output').innerHTML = result.output;
        document.getElementById('status').innerHTML = result.compilationStatus;
      }
    }     
    xmlHttpReq.open('POST', 'eval', true);
    xmlHttpReq.setRequestHeader('Content-Type', 'application/json');
    xmlHttpReq.send(content);
}
      </script>
</body>
</html>
